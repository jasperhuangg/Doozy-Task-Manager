{"ast":null,"code":"// only call this function if a date hasn't already been parsed from the string in TodoList\nexport default function DateParser(str) {\n  const spokenWords = [\"tomorrow\", \"tmr\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\", \"sunday\"];\n  const months = [\"january\", \"february\", \"march\", \"april\", \"may\", \"june\", \"july\", \"august\", \"september\", \"october\", \"november\", \"december\"];\n  const daysWithSuffix = [\"1st\", \"2nd\", \"3rd\", \"4th\", \"5th\", \"6th\", \"7th\", \"8th\", \"9th\", \"10th\", \"11th\", \"12th\", \"13th\", \"14th\", \"15th\", \"16th\", \"17th\", \"18th\", \"19th\", \"20th\", \"21st\", \"22nd\", \"23rd\", \"24th\", \"25th\", \"26th\", \"27th\", \"28th\", \"29th\", \"30th\", \"31st\"];\n  var words = str.toLowerCase().split(\" \");\n  var isSpokenWord = false;\n  var isStringDate = false;\n  var monthBeforeDay = null;\n  var keywords = \"\";\n  var month = \"\";\n  var day = \"\"; // search for any occurences of commonly spoken words\n\n  for (let i = 0; i < spokenWords.length; i++) {\n    var word = spokenWords[i];\n\n    if (words.indexOf(word) !== -1) {\n      keywords = word;\n      isSpokenWord = true;\n      break;\n    }\n  } // if we don't find any commonly spoken words, look for string representations of dates\n\n\n  if (isSpokenWord === false) {\n    // look for months\n    for (let i = 0; i < words.length; i++) {\n      let word = words[i];\n\n      if (months.indexOf(word) !== -1) {\n        month = word;\n        break;\n      }\n    } // if we found a month, look on either side of it for a date\n\n\n    if (month !== \"\") {\n      const monthIndex = words.indexOf(month);\n      var dateCandidates = [];\n      if (monthIndex - 1 >= 0) dateCandidates.push(words[monthIndex - 1]);\n      if (monthIndex + 1 < words.length) dateCandidates.push(words[monthIndex + 1]);\n      console.log(dateCandidates); // check to see if either of these dateCandidates are actual dates with suffixes\n\n      for (let i = 0; i < dateCandidates.length; i++) {\n        const dateCandidate = dateCandidates[i];\n        console.log(dateCandidate);\n\n        if (daysWithSuffix.indexOf(dateCandidate) !== -1) {\n          day = dateCandidate;\n          if (i === 0) monthBeforeDay = false;else monthBeforeDay = true;\n          break;\n        }\n      }\n\n      console.log(day); // if nothing was found, then we look for numeric representations\n\n      if (day === \"\") {\n        for (let i = 0; i < dateCandidates.length; i++) {\n          const dateCandidate = parseInt(dateCandidates[i]);\n\n          if (dateCandidate > 0 && dateCandidate <= 31) {\n            if (i === 0) monthBeforeDay = false;else monthBeforeDay = true;\n            day = dateCandidate;\n            break;\n          }\n        }\n      }\n\n      console.log(day); // if we found a date, then we have a date value\n\n      if (day !== \"\") {\n        isStringDate = true;\n      }\n    }\n  } // create and return the parsed date\n\n\n  if (!isSpokenWord && !isStringDate) return {\n    date: \"\",\n    keywords: \"\"\n  }; // no date found\n  else if (isSpokenWord && !isStringDate) {\n      var today = new Date();\n      var currYear = today.getFullYear();\n      var currMonth = today.getMonth() + 1;\n      var currDate = today.getDate();\n      var currDayOfTheWeek = today.getDay() + 1;\n\n      if (keywords === \"tomorrow\" || keywords === \"tmr\") {\n        var daysInMonth = 31;\n        var day = (currDate + 1) % daysInMonth;\n        var m = day === 1 ? currMonth + 1 : currMonth;\n        m = m % 12 !== 0 ? m % 12 : 1;\n        var year = m === 1 ? currYear + 1 : currYear;\n        return {\n          date: getFormattedDate(year, m, day),\n          keywords: keywords\n        };\n      } else {\n        var dayOfTheWeek = dayOfTheWeekToNumber(keywords); // always going to assume its the next upcoming day\n\n        var difference = distanceToNextDay(currDayOfTheWeek, dayOfTheWeek);\n        var daysInMonth = 31;\n        var day = (currDate + difference) % daysInMonth;\n        var m = day === 1 ? currMonth + 1 : currMonth;\n        m = m % 12 !== 0 ? m % 12 : 1;\n        var year = m === 1 ? currYear + 1 : currYear;\n        return {\n          date: getFormattedDate(year, m, day),\n          keywords: keywords\n        };\n      }\n    } else if (isStringDate && !isSpokenWord) {\n      var today = new Date(); // we will just assume they mean this year (or next year if either come before the current day)\n\n      var currYear = today.getFullYear();\n      var currMonth = today.getMonth() + 1;\n      var currDay = today.getDate();\n      var monthNum = convertMonthToNumber(month);\n      var dayNum = parseInt(day);\n      var year = currYear;\n      if (monthNum < currMonth) year = currYear + 1;else if (monthNum === currMonth) {\n        if (dayNum < currDay) year = currYear + 1;\n      } else year = currYear;\n      var keywordsToReturn = monthBeforeDay ? month + \" \" + day : day + \" \" + month;\n      console.log(month);\n      console.log(day);\n      return {\n        date: getFormattedDate(year, monthNum, dayNum),\n        keywords: keywordsToReturn\n      };\n    }\n}\n\nfunction convertMonthToNumber(month) {\n  const months = [\"\", \"january\", \"february\", \"march\", \"april\", \"may\", \"june\", \"july\", \"august\", \"september\", \"october\", \"november\", \"december\"];\n  return months.indexOf(month);\n}\n\nfunction dayOfTheWeekToNumber(dayOfTheWeek) {\n  const daysOfTheWeek = [\"\", \"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\"];\n  return daysOfTheWeek.indexOf(dayOfTheWeek);\n}\n\nfunction distanceToNextDay(day1, day2) {\n  var diff = 7 - day1 + day2;\n  if (diff !== 7) diff %= 7;\n  return diff;\n}\n\nfunction getFormattedDate(year, month, day) {\n  if (month < 10) month = \"0\" + month.toString();\n  if (day < 10) day = \"0\" + day.toString();\n  return year + \"-\" + month + \"-\" + day;\n}\n\nvar date = DateParser(\"test September test 5 August 5 test\");\nconsole.log(date);","map":{"version":3,"sources":["/Users/jasper.huang/Desktop/Personal_Projects/mern-todolist/client/src/todolist/DateParser.js"],"names":["DateParser","str","spokenWords","months","daysWithSuffix","words","toLowerCase","split","isSpokenWord","isStringDate","monthBeforeDay","keywords","month","day","i","length","word","indexOf","monthIndex","dateCandidates","push","console","log","dateCandidate","parseInt","date","today","Date","currYear","getFullYear","currMonth","getMonth","currDate","getDate","currDayOfTheWeek","getDay","daysInMonth","m","year","getFormattedDate","dayOfTheWeek","dayOfTheWeekToNumber","difference","distanceToNextDay","currDay","monthNum","convertMonthToNumber","dayNum","keywordsToReturn","daysOfTheWeek","day1","day2","diff","toString"],"mappings":"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","sourcesContent":["// only call this function if a date hasn't already been parsed from the string in TodoList\n\nexport default function DateParser(str) {\n  const spokenWords = [\n    \"tomorrow\",\n    \"tmr\",\n    \"monday\",\n    \"tuesday\",\n    \"wednesday\",\n    \"thursday\",\n    \"friday\",\n    \"saturday\",\n    \"sunday\",\n  ];\n\n  const months = [\n    \"january\",\n    \"february\",\n    \"march\",\n    \"april\",\n    \"may\",\n    \"june\",\n    \"july\",\n    \"august\",\n    \"september\",\n    \"october\",\n    \"november\",\n    \"december\",\n  ];\n\n  const daysWithSuffix = [\n    \"1st\",\n    \"2nd\",\n    \"3rd\",\n    \"4th\",\n    \"5th\",\n    \"6th\",\n    \"7th\",\n    \"8th\",\n    \"9th\",\n    \"10th\",\n    \"11th\",\n    \"12th\",\n    \"13th\",\n    \"14th\",\n    \"15th\",\n    \"16th\",\n    \"17th\",\n    \"18th\",\n    \"19th\",\n    \"20th\",\n    \"21st\",\n    \"22nd\",\n    \"23rd\",\n    \"24th\",\n    \"25th\",\n    \"26th\",\n    \"27th\",\n    \"28th\",\n    \"29th\",\n    \"30th\",\n    \"31st\",\n  ];\n\n  var words = str.toLowerCase().split(\" \");\n\n  var isSpokenWord = false;\n  var isStringDate = false;\n  var monthBeforeDay = null;\n  var keywords = \"\";\n  var month = \"\";\n  var day = \"\";\n\n  // search for any occurences of commonly spoken words\n  for (let i = 0; i < spokenWords.length; i++) {\n    var word = spokenWords[i];\n    if (words.indexOf(word) !== -1) {\n      keywords = word;\n      isSpokenWord = true;\n      break;\n    }\n  }\n\n  // if we don't find any commonly spoken words, look for string representations of dates\n  if (isSpokenWord === false) {\n    // look for months\n    for (let i = 0; i < words.length; i++) {\n      let word = words[i];\n      if (months.indexOf(word) !== -1) {\n        month = word;\n        break;\n      }\n    }\n\n    // if we found a month, look on either side of it for a date\n    if (month !== \"\") {\n      const monthIndex = words.indexOf(month);\n      var dateCandidates = [];\n      if (monthIndex - 1 >= 0) dateCandidates.push(words[monthIndex - 1]);\n      if (monthIndex + 1 < words.length)\n        dateCandidates.push(words[monthIndex + 1]);\n      console.log(dateCandidates);\n      // check to see if either of these dateCandidates are actual dates with suffixes\n      for (let i = 0; i < dateCandidates.length; i++) {\n        const dateCandidate = dateCandidates[i];\n        console.log(dateCandidate);\n        if (daysWithSuffix.indexOf(dateCandidate) !== -1) {\n          day = dateCandidate;\n          if (i === 0) monthBeforeDay = false;\n          else monthBeforeDay = true;\n          break;\n        }\n      }\n\n      console.log(day);\n\n      // if nothing was found, then we look for numeric representations\n      if (day === \"\") {\n        for (let i = 0; i < dateCandidates.length; i++) {\n          const dateCandidate = parseInt(dateCandidates[i]);\n          if (dateCandidate > 0 && dateCandidate <= 31) {\n            if (i === 0) monthBeforeDay = false;\n            else monthBeforeDay = true;\n            day = dateCandidate;\n            break;\n          }\n        }\n      }\n      console.log(day);\n\n      // if we found a date, then we have a date value\n      if (day !== \"\") {\n        isStringDate = true;\n      }\n    }\n  }\n\n  // create and return the parsed date\n  if (!isSpokenWord && !isStringDate) return { date: \"\", keywords: \"\" };\n  // no date found\n  else if (isSpokenWord && !isStringDate) {\n    var today = new Date();\n    var currYear = today.getFullYear();\n    var currMonth = today.getMonth() + 1;\n    var currDate = today.getDate();\n    var currDayOfTheWeek = today.getDay() + 1;\n\n    if (keywords === \"tomorrow\" || keywords === \"tmr\") {\n      var daysInMonth = 31;\n      var day = (currDate + 1) % daysInMonth;\n      var m = day === 1 ? currMonth + 1 : currMonth;\n      m = m % 12 !== 0 ? m % 12 : 1;\n      var year = m === 1 ? currYear + 1 : currYear;\n\n      return { date: getFormattedDate(year, m, day), keywords: keywords };\n    } else {\n      var dayOfTheWeek = dayOfTheWeekToNumber(keywords); // always going to assume its the next upcoming day\n      var difference = distanceToNextDay(currDayOfTheWeek, dayOfTheWeek);\n      var daysInMonth = 31;\n      var day = (currDate + difference) % daysInMonth;\n      var m = day === 1 ? currMonth + 1 : currMonth;\n      m = m % 12 !== 0 ? m % 12 : 1;\n      var year = m === 1 ? currYear + 1 : currYear;\n\n      return { date: getFormattedDate(year, m, day), keywords: keywords };\n    }\n  } else if (isStringDate && !isSpokenWord) {\n    var today = new Date(); // we will just assume they mean this year (or next year if either come before the current day)\n    var currYear = today.getFullYear();\n    var currMonth = today.getMonth() + 1;\n    var currDay = today.getDate();\n\n    var monthNum = convertMonthToNumber(month);\n    var dayNum = parseInt(day);\n\n    var year = currYear;\n    if (monthNum < currMonth) year = currYear + 1;\n    else if (monthNum === currMonth) {\n      if (dayNum < currDay) year = currYear + 1;\n    } else year = currYear;\n\n    var keywordsToReturn = monthBeforeDay\n      ? month + \" \" + day\n      : day + \" \" + month;\n\n    console.log(month);\n    console.log(day);\n\n    return {\n      date: getFormattedDate(year, monthNum, dayNum),\n      keywords: keywordsToReturn,\n    };\n  }\n}\n\nfunction convertMonthToNumber(month) {\n  const months = [\n    \"\",\n    \"january\",\n    \"february\",\n    \"march\",\n    \"april\",\n    \"may\",\n    \"june\",\n    \"july\",\n    \"august\",\n    \"september\",\n    \"october\",\n    \"november\",\n    \"december\",\n  ];\n\n  return months.indexOf(month);\n}\n\nfunction dayOfTheWeekToNumber(dayOfTheWeek) {\n  const daysOfTheWeek = [\n    \"\",\n    \"sunday\",\n    \"monday\",\n    \"tuesday\",\n    \"wednesday\",\n    \"thursday\",\n    \"friday\",\n    \"saturday\",\n  ];\n\n  return daysOfTheWeek.indexOf(dayOfTheWeek);\n}\n\nfunction distanceToNextDay(day1, day2) {\n  var diff = 7 - day1 + day2;\n  if (diff !== 7) diff %= 7;\n  return diff;\n}\n\nfunction getFormattedDate(year, month, day) {\n  if (month < 10) month = \"0\" + month.toString();\n  if (day < 10) day = \"0\" + day.toString();\n\n  return year + \"-\" + month + \"-\" + day;\n}\n\nvar date = DateParser(\"test September test 5 August 5 test\");\nconsole.log(date);\n"]},"metadata":{},"sourceType":"module"}