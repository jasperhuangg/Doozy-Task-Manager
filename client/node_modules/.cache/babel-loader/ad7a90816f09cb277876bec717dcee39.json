{"ast":null,"code":"/*!\n * jQuery UI Position 1.12.1\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/position/\n */\n//>>label: Position\n//>>group: Core\n//>>description: Positions elements relative to other elements.\n//>>docs: http://api.jqueryui.com/position/\n//>>demos: http://jqueryui.com/position/\n(function (factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([\"jquery\", \"./version\"], factory);\n  } else {\n    // Browser globals\n    factory(jQuery);\n  }\n})(function ($) {\n  (function () {\n    var cachedScrollbarWidth,\n        max = Math.max,\n        abs = Math.abs,\n        rhorizontal = /left|center|right/,\n        rvertical = /top|center|bottom/,\n        roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n        rposition = /^\\w+/,\n        rpercent = /%$/,\n        _position = $.fn.position;\n\n    function getOffsets(offsets, width, height) {\n      return [parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)];\n    }\n\n    function parseCss(element, property) {\n      return parseInt($.css(element, property), 10) || 0;\n    }\n\n    function getDimensions(elem) {\n      var raw = elem[0];\n\n      if (raw.nodeType === 9) {\n        return {\n          width: elem.width(),\n          height: elem.height(),\n          offset: {\n            top: 0,\n            left: 0\n          }\n        };\n      }\n\n      if ($.isWindow(raw)) {\n        return {\n          width: elem.width(),\n          height: elem.height(),\n          offset: {\n            top: elem.scrollTop(),\n            left: elem.scrollLeft()\n          }\n        };\n      }\n\n      if (raw.preventDefault) {\n        return {\n          width: 0,\n          height: 0,\n          offset: {\n            top: raw.pageY,\n            left: raw.pageX\n          }\n        };\n      }\n\n      return {\n        width: elem.outerWidth(),\n        height: elem.outerHeight(),\n        offset: elem.offset()\n      };\n    }\n\n    $.position = {\n      scrollbarWidth: function () {\n        if (cachedScrollbarWidth !== undefined) {\n          return cachedScrollbarWidth;\n        }\n\n        var w1,\n            w2,\n            div = $(\"<div \" + \"style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>\" + \"<div style='height:100px;width:auto;'></div></div>\"),\n            innerDiv = div.children()[0];\n        $(\"body\").append(div);\n        w1 = innerDiv.offsetWidth;\n        div.css(\"overflow\", \"scroll\");\n        w2 = innerDiv.offsetWidth;\n\n        if (w1 === w2) {\n          w2 = div[0].clientWidth;\n        }\n\n        div.remove();\n        return cachedScrollbarWidth = w1 - w2;\n      },\n      getScrollInfo: function (within) {\n        var overflowX = within.isWindow || within.isDocument ? \"\" : within.element.css(\"overflow-x\"),\n            overflowY = within.isWindow || within.isDocument ? \"\" : within.element.css(\"overflow-y\"),\n            hasOverflowX = overflowX === \"scroll\" || overflowX === \"auto\" && within.width < within.element[0].scrollWidth,\n            hasOverflowY = overflowY === \"scroll\" || overflowY === \"auto\" && within.height < within.element[0].scrollHeight;\n        return {\n          width: hasOverflowY ? $.position.scrollbarWidth() : 0,\n          height: hasOverflowX ? $.position.scrollbarWidth() : 0\n        };\n      },\n      getWithinInfo: function (element) {\n        var withinElement = $(element || window),\n            isWindow = $.isWindow(withinElement[0]),\n            isDocument = !!withinElement[0] && withinElement[0].nodeType === 9,\n            hasOffset = !isWindow && !isDocument;\n        return {\n          element: withinElement,\n          isWindow: isWindow,\n          isDocument: isDocument,\n          offset: hasOffset ? $(element).offset() : {\n            left: 0,\n            top: 0\n          },\n          scrollLeft: withinElement.scrollLeft(),\n          scrollTop: withinElement.scrollTop(),\n          width: withinElement.outerWidth(),\n          height: withinElement.outerHeight()\n        };\n      }\n    };\n\n    $.fn.position = function (options) {\n      if (!options || !options.of) {\n        return _position.apply(this, arguments);\n      } // Make a copy, we don't want to modify arguments\n\n\n      options = $.extend({}, options);\n      var atOffset,\n          targetWidth,\n          targetHeight,\n          targetOffset,\n          basePosition,\n          dimensions,\n          target = $(options.of),\n          within = $.position.getWithinInfo(options.within),\n          scrollInfo = $.position.getScrollInfo(within),\n          collision = (options.collision || \"flip\").split(\" \"),\n          offsets = {};\n      dimensions = getDimensions(target);\n\n      if (target[0].preventDefault) {\n        // Force left top to allow flipping\n        options.at = \"left top\";\n      }\n\n      targetWidth = dimensions.width;\n      targetHeight = dimensions.height;\n      targetOffset = dimensions.offset; // Clone to reuse original targetOffset later\n\n      basePosition = $.extend({}, targetOffset); // Force my and at to have valid horizontal and vertical positions\n      // if a value is missing or invalid, it will be converted to center\n\n      $.each([\"my\", \"at\"], function () {\n        var pos = (options[this] || \"\").split(\" \"),\n            horizontalOffset,\n            verticalOffset;\n\n        if (pos.length === 1) {\n          pos = rhorizontal.test(pos[0]) ? pos.concat([\"center\"]) : rvertical.test(pos[0]) ? [\"center\"].concat(pos) : [\"center\", \"center\"];\n        }\n\n        pos[0] = rhorizontal.test(pos[0]) ? pos[0] : \"center\";\n        pos[1] = rvertical.test(pos[1]) ? pos[1] : \"center\"; // Calculate offsets\n\n        horizontalOffset = roffset.exec(pos[0]);\n        verticalOffset = roffset.exec(pos[1]);\n        offsets[this] = [horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0]; // Reduce to just the positions without the offsets\n\n        options[this] = [rposition.exec(pos[0])[0], rposition.exec(pos[1])[0]];\n      }); // Normalize collision option\n\n      if (collision.length === 1) {\n        collision[1] = collision[0];\n      }\n\n      if (options.at[0] === \"right\") {\n        basePosition.left += targetWidth;\n      } else if (options.at[0] === \"center\") {\n        basePosition.left += targetWidth / 2;\n      }\n\n      if (options.at[1] === \"bottom\") {\n        basePosition.top += targetHeight;\n      } else if (options.at[1] === \"center\") {\n        basePosition.top += targetHeight / 2;\n      }\n\n      atOffset = getOffsets(offsets.at, targetWidth, targetHeight);\n      basePosition.left += atOffset[0];\n      basePosition.top += atOffset[1];\n      return this.each(function () {\n        var collisionPosition,\n            using,\n            elem = $(this),\n            elemWidth = elem.outerWidth(),\n            elemHeight = elem.outerHeight(),\n            marginLeft = parseCss(this, \"marginLeft\"),\n            marginTop = parseCss(this, \"marginTop\"),\n            collisionWidth = elemWidth + marginLeft + parseCss(this, \"marginRight\") + scrollInfo.width,\n            collisionHeight = elemHeight + marginTop + parseCss(this, \"marginBottom\") + scrollInfo.height,\n            position = $.extend({}, basePosition),\n            myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());\n\n        if (options.my[0] === \"right\") {\n          position.left -= elemWidth;\n        } else if (options.my[0] === \"center\") {\n          position.left -= elemWidth / 2;\n        }\n\n        if (options.my[1] === \"bottom\") {\n          position.top -= elemHeight;\n        } else if (options.my[1] === \"center\") {\n          position.top -= elemHeight / 2;\n        }\n\n        position.left += myOffset[0];\n        position.top += myOffset[1];\n        collisionPosition = {\n          marginLeft: marginLeft,\n          marginTop: marginTop\n        };\n        $.each([\"left\", \"top\"], function (i, dir) {\n          if ($.ui.position[collision[i]]) {\n            $.ui.position[collision[i]][dir](position, {\n              targetWidth: targetWidth,\n              targetHeight: targetHeight,\n              elemWidth: elemWidth,\n              elemHeight: elemHeight,\n              collisionPosition: collisionPosition,\n              collisionWidth: collisionWidth,\n              collisionHeight: collisionHeight,\n              offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],\n              my: options.my,\n              at: options.at,\n              within: within,\n              elem: elem\n            });\n          }\n        });\n\n        if (options.using) {\n          // Adds feedback as second argument to using callback, if present\n          using = function (props) {\n            var left = targetOffset.left - position.left,\n                right = left + targetWidth - elemWidth,\n                top = targetOffset.top - position.top,\n                bottom = top + targetHeight - elemHeight,\n                feedback = {\n              target: {\n                element: target,\n                left: targetOffset.left,\n                top: targetOffset.top,\n                width: targetWidth,\n                height: targetHeight\n              },\n              element: {\n                element: elem,\n                left: position.left,\n                top: position.top,\n                width: elemWidth,\n                height: elemHeight\n              },\n              horizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\n              vertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\n            };\n\n            if (targetWidth < elemWidth && abs(left + right) < targetWidth) {\n              feedback.horizontal = \"center\";\n            }\n\n            if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {\n              feedback.vertical = \"middle\";\n            }\n\n            if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {\n              feedback.important = \"horizontal\";\n            } else {\n              feedback.important = \"vertical\";\n            }\n\n            options.using.call(this, props, feedback);\n          };\n        }\n\n        elem.offset($.extend(position, {\n          using: using\n        }));\n      });\n    };\n\n    $.ui.position = {\n      fit: {\n        left: function (position, data) {\n          var within = data.within,\n              withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n              outerWidth = within.width,\n              collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n              overLeft = withinOffset - collisionPosLeft,\n              overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n              newOverRight; // Element is wider than within\n\n          if (data.collisionWidth > outerWidth) {\n            // Element is initially over the left side of within\n            if (overLeft > 0 && overRight <= 0) {\n              newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;\n              position.left += overLeft - newOverRight; // Element is initially over right side of within\n            } else if (overRight > 0 && overLeft <= 0) {\n              position.left = withinOffset; // Element is initially over both left and right sides of within\n            } else {\n              if (overLeft > overRight) {\n                position.left = withinOffset + outerWidth - data.collisionWidth;\n              } else {\n                position.left = withinOffset;\n              }\n            } // Too far left -> align with left edge\n\n          } else if (overLeft > 0) {\n            position.left += overLeft; // Too far right -> align with right edge\n          } else if (overRight > 0) {\n            position.left -= overRight; // Adjust based on position and margin\n          } else {\n            position.left = max(position.left - collisionPosLeft, position.left);\n          }\n        },\n        top: function (position, data) {\n          var within = data.within,\n              withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n              outerHeight = data.within.height,\n              collisionPosTop = position.top - data.collisionPosition.marginTop,\n              overTop = withinOffset - collisionPosTop,\n              overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n              newOverBottom; // Element is taller than within\n\n          if (data.collisionHeight > outerHeight) {\n            // Element is initially over the top of within\n            if (overTop > 0 && overBottom <= 0) {\n              newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;\n              position.top += overTop - newOverBottom; // Element is initially over bottom of within\n            } else if (overBottom > 0 && overTop <= 0) {\n              position.top = withinOffset; // Element is initially over both top and bottom of within\n            } else {\n              if (overTop > overBottom) {\n                position.top = withinOffset + outerHeight - data.collisionHeight;\n              } else {\n                position.top = withinOffset;\n              }\n            } // Too far up -> align with top\n\n          } else if (overTop > 0) {\n            position.top += overTop; // Too far down -> align with bottom edge\n          } else if (overBottom > 0) {\n            position.top -= overBottom; // Adjust based on position and margin\n          } else {\n            position.top = max(position.top - collisionPosTop, position.top);\n          }\n        }\n      },\n      flip: {\n        left: function (position, data) {\n          var within = data.within,\n              withinOffset = within.offset.left + within.scrollLeft,\n              outerWidth = within.width,\n              offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n              collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n              overLeft = collisionPosLeft - offsetLeft,\n              overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n              myOffset = data.my[0] === \"left\" ? -data.elemWidth : data.my[0] === \"right\" ? data.elemWidth : 0,\n              atOffset = data.at[0] === \"left\" ? data.targetWidth : data.at[0] === \"right\" ? -data.targetWidth : 0,\n              offset = -2 * data.offset[0],\n              newOverRight,\n              newOverLeft;\n\n          if (overLeft < 0) {\n            newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;\n\n            if (newOverRight < 0 || newOverRight < abs(overLeft)) {\n              position.left += myOffset + atOffset + offset;\n            }\n          } else if (overRight > 0) {\n            newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;\n\n            if (newOverLeft > 0 || abs(newOverLeft) < overRight) {\n              position.left += myOffset + atOffset + offset;\n            }\n          }\n        },\n        top: function (position, data) {\n          var within = data.within,\n              withinOffset = within.offset.top + within.scrollTop,\n              outerHeight = within.height,\n              offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n              collisionPosTop = position.top - data.collisionPosition.marginTop,\n              overTop = collisionPosTop - offsetTop,\n              overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n              top = data.my[1] === \"top\",\n              myOffset = top ? -data.elemHeight : data.my[1] === \"bottom\" ? data.elemHeight : 0,\n              atOffset = data.at[1] === \"top\" ? data.targetHeight : data.at[1] === \"bottom\" ? -data.targetHeight : 0,\n              offset = -2 * data.offset[1],\n              newOverTop,\n              newOverBottom;\n\n          if (overTop < 0) {\n            newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;\n\n            if (newOverBottom < 0 || newOverBottom < abs(overTop)) {\n              position.top += myOffset + atOffset + offset;\n            }\n          } else if (overBottom > 0) {\n            newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;\n\n            if (newOverTop > 0 || abs(newOverTop) < overBottom) {\n              position.top += myOffset + atOffset + offset;\n            }\n          }\n        }\n      },\n      flipfit: {\n        left: function () {\n          $.ui.position.flip.left.apply(this, arguments);\n          $.ui.position.fit.left.apply(this, arguments);\n        },\n        top: function () {\n          $.ui.position.flip.top.apply(this, arguments);\n          $.ui.position.fit.top.apply(this, arguments);\n        }\n      }\n    };\n  })();\n\n  return $.ui.position;\n});","map":{"version":3,"sources":["/Users/jasper.huang/Desktop/Personal_Projects/mern-todolist/client/node_modules/jquery-ui/ui/position.js"],"names":["factory","define","amd","jQuery","$","cachedScrollbarWidth","max","Math","abs","rhorizontal","rvertical","roffset","rposition","rpercent","_position","fn","position","getOffsets","offsets","width","height","parseFloat","test","parseCss","element","property","parseInt","css","getDimensions","elem","raw","nodeType","offset","top","left","isWindow","scrollTop","scrollLeft","preventDefault","pageY","pageX","outerWidth","outerHeight","scrollbarWidth","undefined","w1","w2","div","innerDiv","children","append","offsetWidth","clientWidth","remove","getScrollInfo","within","overflowX","isDocument","overflowY","hasOverflowX","scrollWidth","hasOverflowY","scrollHeight","getWithinInfo","withinElement","window","hasOffset","options","of","apply","arguments","extend","atOffset","targetWidth","targetHeight","targetOffset","basePosition","dimensions","target","scrollInfo","collision","split","at","each","pos","horizontalOffset","verticalOffset","length","concat","exec","collisionPosition","using","elemWidth","elemHeight","marginLeft","marginTop","collisionWidth","collisionHeight","myOffset","my","i","dir","ui","props","right","bottom","feedback","horizontal","vertical","important","call","fit","data","withinOffset","collisionPosLeft","overLeft","overRight","newOverRight","collisionPosTop","overTop","overBottom","newOverBottom","flip","offsetLeft","newOverLeft","offsetTop","newOverTop","flipfit"],"mappings":"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","sourcesContent":["/*!\n * jQuery UI Position 1.12.1\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/position/\n */\n\n//>>label: Position\n//>>group: Core\n//>>description: Positions elements relative to other elements.\n//>>docs: http://api.jqueryui.com/position/\n//>>demos: http://jqueryui.com/position/\n\n( function( factory ) {\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine( [ \"jquery\", \"./version\" ], factory );\n\t} else {\n\n\t\t// Browser globals\n\t\tfactory( jQuery );\n\t}\n}( function( $ ) {\n( function() {\nvar cachedScrollbarWidth,\n\tmax = Math.max,\n\tabs = Math.abs,\n\trhorizontal = /left|center|right/,\n\trvertical = /top|center|bottom/,\n\troffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n\trposition = /^\\w+/,\n\trpercent = /%$/,\n\t_position = $.fn.position;\n\nfunction getOffsets( offsets, width, height ) {\n\treturn [\n\t\tparseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\n\t\tparseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\n\t];\n}\n\nfunction parseCss( element, property ) {\n\treturn parseInt( $.css( element, property ), 10 ) || 0;\n}\n\nfunction getDimensions( elem ) {\n\tvar raw = elem[ 0 ];\n\tif ( raw.nodeType === 9 ) {\n\t\treturn {\n\t\t\twidth: elem.width(),\n\t\t\theight: elem.height(),\n\t\t\toffset: { top: 0, left: 0 }\n\t\t};\n\t}\n\tif ( $.isWindow( raw ) ) {\n\t\treturn {\n\t\t\twidth: elem.width(),\n\t\t\theight: elem.height(),\n\t\t\toffset: { top: elem.scrollTop(), left: elem.scrollLeft() }\n\t\t};\n\t}\n\tif ( raw.preventDefault ) {\n\t\treturn {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\toffset: { top: raw.pageY, left: raw.pageX }\n\t\t};\n\t}\n\treturn {\n\t\twidth: elem.outerWidth(),\n\t\theight: elem.outerHeight(),\n\t\toffset: elem.offset()\n\t};\n}\n\n$.position = {\n\tscrollbarWidth: function() {\n\t\tif ( cachedScrollbarWidth !== undefined ) {\n\t\t\treturn cachedScrollbarWidth;\n\t\t}\n\t\tvar w1, w2,\n\t\t\tdiv = $( \"<div \" +\n\t\t\t\t\"style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>\" +\n\t\t\t\t\"<div style='height:100px;width:auto;'></div></div>\" ),\n\t\t\tinnerDiv = div.children()[ 0 ];\n\n\t\t$( \"body\" ).append( div );\n\t\tw1 = innerDiv.offsetWidth;\n\t\tdiv.css( \"overflow\", \"scroll\" );\n\n\t\tw2 = innerDiv.offsetWidth;\n\n\t\tif ( w1 === w2 ) {\n\t\t\tw2 = div[ 0 ].clientWidth;\n\t\t}\n\n\t\tdiv.remove();\n\n\t\treturn ( cachedScrollbarWidth = w1 - w2 );\n\t},\n\tgetScrollInfo: function( within ) {\n\t\tvar overflowX = within.isWindow || within.isDocument ? \"\" :\n\t\t\t\twithin.element.css( \"overflow-x\" ),\n\t\t\toverflowY = within.isWindow || within.isDocument ? \"\" :\n\t\t\t\twithin.element.css( \"overflow-y\" ),\n\t\t\thasOverflowX = overflowX === \"scroll\" ||\n\t\t\t\t( overflowX === \"auto\" && within.width < within.element[ 0 ].scrollWidth ),\n\t\t\thasOverflowY = overflowY === \"scroll\" ||\n\t\t\t\t( overflowY === \"auto\" && within.height < within.element[ 0 ].scrollHeight );\n\t\treturn {\n\t\t\twidth: hasOverflowY ? $.position.scrollbarWidth() : 0,\n\t\t\theight: hasOverflowX ? $.position.scrollbarWidth() : 0\n\t\t};\n\t},\n\tgetWithinInfo: function( element ) {\n\t\tvar withinElement = $( element || window ),\n\t\t\tisWindow = $.isWindow( withinElement[ 0 ] ),\n\t\t\tisDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,\n\t\t\thasOffset = !isWindow && !isDocument;\n\t\treturn {\n\t\t\telement: withinElement,\n\t\t\tisWindow: isWindow,\n\t\t\tisDocument: isDocument,\n\t\t\toffset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },\n\t\t\tscrollLeft: withinElement.scrollLeft(),\n\t\t\tscrollTop: withinElement.scrollTop(),\n\t\t\twidth: withinElement.outerWidth(),\n\t\t\theight: withinElement.outerHeight()\n\t\t};\n\t}\n};\n\n$.fn.position = function( options ) {\n\tif ( !options || !options.of ) {\n\t\treturn _position.apply( this, arguments );\n\t}\n\n\t// Make a copy, we don't want to modify arguments\n\toptions = $.extend( {}, options );\n\n\tvar atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\n\t\ttarget = $( options.of ),\n\t\twithin = $.position.getWithinInfo( options.within ),\n\t\tscrollInfo = $.position.getScrollInfo( within ),\n\t\tcollision = ( options.collision || \"flip\" ).split( \" \" ),\n\t\toffsets = {};\n\n\tdimensions = getDimensions( target );\n\tif ( target[ 0 ].preventDefault ) {\n\n\t\t// Force left top to allow flipping\n\t\toptions.at = \"left top\";\n\t}\n\ttargetWidth = dimensions.width;\n\ttargetHeight = dimensions.height;\n\ttargetOffset = dimensions.offset;\n\n\t// Clone to reuse original targetOffset later\n\tbasePosition = $.extend( {}, targetOffset );\n\n\t// Force my and at to have valid horizontal and vertical positions\n\t// if a value is missing or invalid, it will be converted to center\n\t$.each( [ \"my\", \"at\" ], function() {\n\t\tvar pos = ( options[ this ] || \"\" ).split( \" \" ),\n\t\t\thorizontalOffset,\n\t\t\tverticalOffset;\n\n\t\tif ( pos.length === 1 ) {\n\t\t\tpos = rhorizontal.test( pos[ 0 ] ) ?\n\t\t\t\tpos.concat( [ \"center\" ] ) :\n\t\t\t\trvertical.test( pos[ 0 ] ) ?\n\t\t\t\t\t[ \"center\" ].concat( pos ) :\n\t\t\t\t\t[ \"center\", \"center\" ];\n\t\t}\n\t\tpos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\n\t\tpos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\n\n\t\t// Calculate offsets\n\t\thorizontalOffset = roffset.exec( pos[ 0 ] );\n\t\tverticalOffset = roffset.exec( pos[ 1 ] );\n\t\toffsets[ this ] = [\n\t\t\thorizontalOffset ? horizontalOffset[ 0 ] : 0,\n\t\t\tverticalOffset ? verticalOffset[ 0 ] : 0\n\t\t];\n\n\t\t// Reduce to just the positions without the offsets\n\t\toptions[ this ] = [\n\t\t\trposition.exec( pos[ 0 ] )[ 0 ],\n\t\t\trposition.exec( pos[ 1 ] )[ 0 ]\n\t\t];\n\t} );\n\n\t// Normalize collision option\n\tif ( collision.length === 1 ) {\n\t\tcollision[ 1 ] = collision[ 0 ];\n\t}\n\n\tif ( options.at[ 0 ] === \"right\" ) {\n\t\tbasePosition.left += targetWidth;\n\t} else if ( options.at[ 0 ] === \"center\" ) {\n\t\tbasePosition.left += targetWidth / 2;\n\t}\n\n\tif ( options.at[ 1 ] === \"bottom\" ) {\n\t\tbasePosition.top += targetHeight;\n\t} else if ( options.at[ 1 ] === \"center\" ) {\n\t\tbasePosition.top += targetHeight / 2;\n\t}\n\n\tatOffset = getOffsets( offsets.at, targetWidth, targetHeight );\n\tbasePosition.left += atOffset[ 0 ];\n\tbasePosition.top += atOffset[ 1 ];\n\n\treturn this.each( function() {\n\t\tvar collisionPosition, using,\n\t\t\telem = $( this ),\n\t\t\telemWidth = elem.outerWidth(),\n\t\t\telemHeight = elem.outerHeight(),\n\t\t\tmarginLeft = parseCss( this, \"marginLeft\" ),\n\t\t\tmarginTop = parseCss( this, \"marginTop\" ),\n\t\t\tcollisionWidth = elemWidth + marginLeft + parseCss( this, \"marginRight\" ) +\n\t\t\t\tscrollInfo.width,\n\t\t\tcollisionHeight = elemHeight + marginTop + parseCss( this, \"marginBottom\" ) +\n\t\t\t\tscrollInfo.height,\n\t\t\tposition = $.extend( {}, basePosition ),\n\t\t\tmyOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );\n\n\t\tif ( options.my[ 0 ] === \"right\" ) {\n\t\t\tposition.left -= elemWidth;\n\t\t} else if ( options.my[ 0 ] === \"center\" ) {\n\t\t\tposition.left -= elemWidth / 2;\n\t\t}\n\n\t\tif ( options.my[ 1 ] === \"bottom\" ) {\n\t\t\tposition.top -= elemHeight;\n\t\t} else if ( options.my[ 1 ] === \"center\" ) {\n\t\t\tposition.top -= elemHeight / 2;\n\t\t}\n\n\t\tposition.left += myOffset[ 0 ];\n\t\tposition.top += myOffset[ 1 ];\n\n\t\tcollisionPosition = {\n\t\t\tmarginLeft: marginLeft,\n\t\t\tmarginTop: marginTop\n\t\t};\n\n\t\t$.each( [ \"left\", \"top\" ], function( i, dir ) {\n\t\t\tif ( $.ui.position[ collision[ i ] ] ) {\n\t\t\t\t$.ui.position[ collision[ i ] ][ dir ]( position, {\n\t\t\t\t\ttargetWidth: targetWidth,\n\t\t\t\t\ttargetHeight: targetHeight,\n\t\t\t\t\telemWidth: elemWidth,\n\t\t\t\t\telemHeight: elemHeight,\n\t\t\t\t\tcollisionPosition: collisionPosition,\n\t\t\t\t\tcollisionWidth: collisionWidth,\n\t\t\t\t\tcollisionHeight: collisionHeight,\n\t\t\t\t\toffset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\n\t\t\t\t\tmy: options.my,\n\t\t\t\t\tat: options.at,\n\t\t\t\t\twithin: within,\n\t\t\t\t\telem: elem\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\tif ( options.using ) {\n\n\t\t\t// Adds feedback as second argument to using callback, if present\n\t\t\tusing = function( props ) {\n\t\t\t\tvar left = targetOffset.left - position.left,\n\t\t\t\t\tright = left + targetWidth - elemWidth,\n\t\t\t\t\ttop = targetOffset.top - position.top,\n\t\t\t\t\tbottom = top + targetHeight - elemHeight,\n\t\t\t\t\tfeedback = {\n\t\t\t\t\t\ttarget: {\n\t\t\t\t\t\t\telement: target,\n\t\t\t\t\t\t\tleft: targetOffset.left,\n\t\t\t\t\t\t\ttop: targetOffset.top,\n\t\t\t\t\t\t\twidth: targetWidth,\n\t\t\t\t\t\t\theight: targetHeight\n\t\t\t\t\t\t},\n\t\t\t\t\t\telement: {\n\t\t\t\t\t\t\telement: elem,\n\t\t\t\t\t\t\tleft: position.left,\n\t\t\t\t\t\t\ttop: position.top,\n\t\t\t\t\t\t\twidth: elemWidth,\n\t\t\t\t\t\t\theight: elemHeight\n\t\t\t\t\t\t},\n\t\t\t\t\t\thorizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\n\t\t\t\t\t\tvertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\n\t\t\t\t\t};\n\t\t\t\tif ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\n\t\t\t\t\tfeedback.horizontal = \"center\";\n\t\t\t\t}\n\t\t\t\tif ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\n\t\t\t\t\tfeedback.vertical = \"middle\";\n\t\t\t\t}\n\t\t\t\tif ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\n\t\t\t\t\tfeedback.important = \"horizontal\";\n\t\t\t\t} else {\n\t\t\t\t\tfeedback.important = \"vertical\";\n\t\t\t\t}\n\t\t\t\toptions.using.call( this, props, feedback );\n\t\t\t};\n\t\t}\n\n\t\telem.offset( $.extend( position, { using: using } ) );\n\t} );\n};\n\n$.ui.position = {\n\tfit: {\n\t\tleft: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\touterWidth = within.width,\n\t\t\t\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\toverLeft = withinOffset - collisionPosLeft,\n\t\t\t\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n\t\t\t\tnewOverRight;\n\n\t\t\t// Element is wider than within\n\t\t\tif ( data.collisionWidth > outerWidth ) {\n\n\t\t\t\t// Element is initially over the left side of within\n\t\t\t\tif ( overLeft > 0 && overRight <= 0 ) {\n\t\t\t\t\tnewOverRight = position.left + overLeft + data.collisionWidth - outerWidth -\n\t\t\t\t\t\twithinOffset;\n\t\t\t\t\tposition.left += overLeft - newOverRight;\n\n\t\t\t\t// Element is initially over right side of within\n\t\t\t\t} else if ( overRight > 0 && overLeft <= 0 ) {\n\t\t\t\t\tposition.left = withinOffset;\n\n\t\t\t\t// Element is initially over both left and right sides of within\n\t\t\t\t} else {\n\t\t\t\t\tif ( overLeft > overRight ) {\n\t\t\t\t\t\tposition.left = withinOffset + outerWidth - data.collisionWidth;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.left = withinOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Too far left -> align with left edge\n\t\t\t} else if ( overLeft > 0 ) {\n\t\t\t\tposition.left += overLeft;\n\n\t\t\t// Too far right -> align with right edge\n\t\t\t} else if ( overRight > 0 ) {\n\t\t\t\tposition.left -= overRight;\n\n\t\t\t// Adjust based on position and margin\n\t\t\t} else {\n\t\t\t\tposition.left = max( position.left - collisionPosLeft, position.left );\n\t\t\t}\n\t\t},\n\t\ttop: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\touterHeight = data.within.height,\n\t\t\t\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\toverTop = withinOffset - collisionPosTop,\n\t\t\t\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n\t\t\t\tnewOverBottom;\n\n\t\t\t// Element is taller than within\n\t\t\tif ( data.collisionHeight > outerHeight ) {\n\n\t\t\t\t// Element is initially over the top of within\n\t\t\t\tif ( overTop > 0 && overBottom <= 0 ) {\n\t\t\t\t\tnewOverBottom = position.top + overTop + data.collisionHeight - outerHeight -\n\t\t\t\t\t\twithinOffset;\n\t\t\t\t\tposition.top += overTop - newOverBottom;\n\n\t\t\t\t// Element is initially over bottom of within\n\t\t\t\t} else if ( overBottom > 0 && overTop <= 0 ) {\n\t\t\t\t\tposition.top = withinOffset;\n\n\t\t\t\t// Element is initially over both top and bottom of within\n\t\t\t\t} else {\n\t\t\t\t\tif ( overTop > overBottom ) {\n\t\t\t\t\t\tposition.top = withinOffset + outerHeight - data.collisionHeight;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.top = withinOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Too far up -> align with top\n\t\t\t} else if ( overTop > 0 ) {\n\t\t\t\tposition.top += overTop;\n\n\t\t\t// Too far down -> align with bottom edge\n\t\t\t} else if ( overBottom > 0 ) {\n\t\t\t\tposition.top -= overBottom;\n\n\t\t\t// Adjust based on position and margin\n\t\t\t} else {\n\t\t\t\tposition.top = max( position.top - collisionPosTop, position.top );\n\t\t\t}\n\t\t}\n\t},\n\tflip: {\n\t\tleft: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.offset.left + within.scrollLeft,\n\t\t\t\touterWidth = within.width,\n\t\t\t\toffsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\toverLeft = collisionPosLeft - offsetLeft,\n\t\t\t\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n\t\t\t\tmyOffset = data.my[ 0 ] === \"left\" ?\n\t\t\t\t\t-data.elemWidth :\n\t\t\t\t\tdata.my[ 0 ] === \"right\" ?\n\t\t\t\t\t\tdata.elemWidth :\n\t\t\t\t\t\t0,\n\t\t\t\tatOffset = data.at[ 0 ] === \"left\" ?\n\t\t\t\t\tdata.targetWidth :\n\t\t\t\t\tdata.at[ 0 ] === \"right\" ?\n\t\t\t\t\t\t-data.targetWidth :\n\t\t\t\t\t\t0,\n\t\t\t\toffset = -2 * data.offset[ 0 ],\n\t\t\t\tnewOverRight,\n\t\t\t\tnewOverLeft;\n\n\t\t\tif ( overLeft < 0 ) {\n\t\t\t\tnewOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -\n\t\t\t\t\touterWidth - withinOffset;\n\t\t\t\tif ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\n\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t} else if ( overRight > 0 ) {\n\t\t\t\tnewOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +\n\t\t\t\t\tatOffset + offset - offsetLeft;\n\t\t\t\tif ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\n\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ttop: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.offset.top + within.scrollTop,\n\t\t\t\touterHeight = within.height,\n\t\t\t\toffsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\toverTop = collisionPosTop - offsetTop,\n\t\t\t\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n\t\t\t\ttop = data.my[ 1 ] === \"top\",\n\t\t\t\tmyOffset = top ?\n\t\t\t\t\t-data.elemHeight :\n\t\t\t\t\tdata.my[ 1 ] === \"bottom\" ?\n\t\t\t\t\t\tdata.elemHeight :\n\t\t\t\t\t\t0,\n\t\t\t\tatOffset = data.at[ 1 ] === \"top\" ?\n\t\t\t\t\tdata.targetHeight :\n\t\t\t\t\tdata.at[ 1 ] === \"bottom\" ?\n\t\t\t\t\t\t-data.targetHeight :\n\t\t\t\t\t\t0,\n\t\t\t\toffset = -2 * data.offset[ 1 ],\n\t\t\t\tnewOverTop,\n\t\t\t\tnewOverBottom;\n\t\t\tif ( overTop < 0 ) {\n\t\t\t\tnewOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -\n\t\t\t\t\touterHeight - withinOffset;\n\t\t\t\tif ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {\n\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t} else if ( overBottom > 0 ) {\n\t\t\t\tnewOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +\n\t\t\t\t\toffset - offsetTop;\n\t\t\t\tif ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {\n\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tflipfit: {\n\t\tleft: function() {\n\t\t\t$.ui.position.flip.left.apply( this, arguments );\n\t\t\t$.ui.position.fit.left.apply( this, arguments );\n\t\t},\n\t\ttop: function() {\n\t\t\t$.ui.position.flip.top.apply( this, arguments );\n\t\t\t$.ui.position.fit.top.apply( this, arguments );\n\t\t}\n\t}\n};\n\n} )();\n\nreturn $.ui.position;\n\n} ) );\n"]},"metadata":{},"sourceType":"script"}