{"ast":null,"code":"// only call this function if a date hasn't already been parsed from the string in TodoList\nexport default function DateParser(str) {\n  const spokenWords = [\"tomorrow\", \"tmr\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\", \"sunday\"];\n  const months = [\"january\", \"february\", \"march\", \"april\", \"may\", \"june\", \"july\", \"august\", \"september\", \"october\", \"november\", \"december\"];\n  const daysWithSuffix = [\"1st\", \"2nd\", \"3rd\", \"4th\", \"5th\", \"6th\", \"7th\", \"8th\", \"9th\", \"10th\", \"11th\", \"12th\", \"13th\", \"14th\", \"15th\", \"16th\", \"17th\", \"18th\", \"19th\", \"20th\", \"21st\", \"22nd\", \"23rd\", \"24th\", \"25th\", \"26th\", \"27th\", \"28th\", \"29th\", \"30th\", \"31st\"];\n  var words = str.toLowerCase().split(\" \");\n  var isSpokenWord = false;\n  var isStringDate = false;\n  var monthBeforeDay = null;\n  var keywords = \"\";\n  var month = \"\";\n  var monthCandidates = [];\n  var day = \"\"; // search for any occurences of commonly spoken words\n\n  for (let i = 0; i < spokenWords.length; i++) {\n    var word = spokenWords[i];\n\n    if (words.indexOf(word) !== -1) {\n      keywords = word;\n      isSpokenWord = true;\n      break;\n    }\n  } // if we don't find any commonly spoken words, look for string representations of dates\n\n\n  if (isSpokenWord === false) {\n    // look for months\n    for (let i = 0; i < words.length; i++) {\n      let word = words[i];\n\n      if (months.indexOf(word) !== -1) {\n        monthCandidates.push(word);\n      }\n    }\n\n    console.log(words);\n    console.log(monthCandidates); // if we found a month, look on either side of it for a date\n\n    if (monthCandidates.length > 0) {\n      // check each month candidate\n      for (let f = 0; f < monthCandidates.length; f++) {\n        var monthCandidate = monthCandidates[f];\n        const monthIndex = getPosition(words, monthCandidate, f + 1);\n        var dateCandidates = [];\n        if (monthIndex - 1 >= 0) dateCandidates.push({\n          index: monthIndex - 1,\n          date: words[monthIndex - 1]\n        });\n        if (monthIndex + 1 < words.length) dateCandidates.push({\n          index: monthIndex + 1,\n          date: words[monthIndex + 1]\n        }); // check to see if either of these dateCandidates are actual dates with suffixes\n\n        for (let i = 0; i < dateCandidates.length; i++) {\n          const dateCandidate = dateCandidates[i].date;\n          const idx = dateCandidates[i].index;\n\n          if (daysWithSuffix.indexOf(dateCandidate) !== -1) {\n            day = dateCandidate;\n            if (idx > monthIndex) monthBeforeDay = true;else monthBeforeDay = false;\n            break;\n          }\n        } // if nothing was found, then we look for numeric representations\n\n\n        if (day === \"\") {\n          for (let i = 0; i < dateCandidates.length; i++) {\n            const dateCandidate = parseInt(dateCandidates[i].date);\n            const idx = dateCandidates[i].index;\n\n            if (dateCandidate > 0 && dateCandidate <= 31) {\n              day = dateCandidate;\n              if (idx > monthIndex) monthBeforeDay = true;else monthBeforeDay = false;\n              break;\n            }\n          }\n        } // if we found a date, then we have a date value\n\n\n        if (day !== \"\") {\n          isStringDate = true;\n          month = monthCandidates[f];\n          break;\n        }\n      }\n    }\n  } // create and return the parsed date\n\n\n  if (!isSpokenWord && !isStringDate) return {\n    date: \"\",\n    keywords: \"\"\n  }; // no date found\n  else if (isSpokenWord && !isStringDate) {\n      var today = new Date();\n      var currYear = today.getFullYear();\n      var currMonth = today.getMonth() + 1;\n      var currDate = today.getDate();\n      var currDayOfTheWeek = today.getDay() + 1;\n\n      if (keywords === \"tomorrow\" || keywords === \"tmr\") {\n        var daysInMonth = 31;\n        var day = (currDate + 1) % daysInMonth;\n        var m = day === 1 ? currMonth + 1 : currMonth;\n        m = m % 12 !== 0 ? m % 12 : 1;\n        var year = m === 1 ? currYear + 1 : currYear;\n        return {\n          date: getFormattedDate(year, m, day),\n          keywords: keywords\n        };\n      } else {\n        var dayOfTheWeek = dayOfTheWeekToNumber(keywords); // always going to assume its the next upcoming day\n\n        var difference = distanceToNextDay(currDayOfTheWeek, dayOfTheWeek);\n        var daysInMonth = 31;\n        var day = (currDate + difference) % daysInMonth;\n        var m = day === 1 ? currMonth + 1 : currMonth;\n        m = m % 12 !== 0 ? m % 12 : 1;\n        var year = m === 1 ? currYear + 1 : currYear;\n        return {\n          date: getFormattedDate(year, m, day),\n          keywords: keywords\n        };\n      }\n    } else if (isStringDate && !isSpokenWord) {\n      var today = new Date(); // we will just assume they mean this year (or next year if either come before the current day)\n\n      var currYear = today.getFullYear();\n      var currMonth = today.getMonth() + 1;\n      var currDay = today.getDate();\n      var monthNum = convertMonthToNumber(month);\n      var dayNum = parseInt(day);\n      var year = currYear;\n      if (monthNum < currMonth) year = currYear + 1;else if (monthNum === currMonth) {\n        if (dayNum < currDay) year = currYear + 1;\n      } else year = currYear;\n      var keywordsToReturn = monthBeforeDay ? month + \" \" + day : day + \" \" + month;\n      return {\n        date: getFormattedDate(year, monthNum, dayNum),\n        keywords: keywordsToReturn\n      };\n    }\n}\n\nfunction convertMonthToNumber(month) {\n  const months = [\"\", \"january\", \"february\", \"march\", \"april\", \"may\", \"june\", \"july\", \"august\", \"september\", \"october\", \"november\", \"december\"];\n  return months.indexOf(month);\n}\n\nfunction dayOfTheWeekToNumber(dayOfTheWeek) {\n  const daysOfTheWeek = [\"\", \"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\"];\n  return daysOfTheWeek.indexOf(dayOfTheWeek);\n}\n\nfunction distanceToNextDay(day1, day2) {\n  var diff = 7 - day1 + day2;\n  if (diff !== 7) diff %= 7;\n  return diff;\n}\n\nfunction getFormattedDate(year, month, day) {\n  if (month < 10) month = \"0\" + month.toString();\n  if (day < 10) day = \"0\" + day.toString();\n  return year + \"-\" + month + \"-\" + day;\n}\n\nfunction getPosition(array, entry, occurence) {\n  var seen = 0;\n\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === entry) {\n      seen++;\n      if (seen === occurence) return i;\n    }\n  }\n}\n\nvar date = DateParser(\"test december 423 nice august 15 li\");\nconsole.log(date);","map":{"version":3,"sources":["/Users/jasper.huang/Desktop/Personal_Projects/mern-todolist/client/src/todolist/DateParser.js"],"names":["DateParser","str","spokenWords","months","daysWithSuffix","words","toLowerCase","split","isSpokenWord","isStringDate","monthBeforeDay","keywords","month","monthCandidates","day","i","length","word","indexOf","push","console","log","f","monthCandidate","monthIndex","getPosition","dateCandidates","index","date","dateCandidate","idx","parseInt","today","Date","currYear","getFullYear","currMonth","getMonth","currDate","getDate","currDayOfTheWeek","getDay","daysInMonth","m","year","getFormattedDate","dayOfTheWeek","dayOfTheWeekToNumber","difference","distanceToNextDay","currDay","monthNum","convertMonthToNumber","dayNum","keywordsToReturn","daysOfTheWeek","day1","day2","diff","toString","array","entry","occurence","seen"],"mappings":"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","sourcesContent":["// only call this function if a date hasn't already been parsed from the string in TodoList\n\nexport default function DateParser(str) {\n  const spokenWords = [\n    \"tomorrow\",\n    \"tmr\",\n    \"monday\",\n    \"tuesday\",\n    \"wednesday\",\n    \"thursday\",\n    \"friday\",\n    \"saturday\",\n    \"sunday\",\n  ];\n\n  const months = [\n    \"january\",\n    \"february\",\n    \"march\",\n    \"april\",\n    \"may\",\n    \"june\",\n    \"july\",\n    \"august\",\n    \"september\",\n    \"october\",\n    \"november\",\n    \"december\",\n  ];\n\n  const daysWithSuffix = [\n    \"1st\",\n    \"2nd\",\n    \"3rd\",\n    \"4th\",\n    \"5th\",\n    \"6th\",\n    \"7th\",\n    \"8th\",\n    \"9th\",\n    \"10th\",\n    \"11th\",\n    \"12th\",\n    \"13th\",\n    \"14th\",\n    \"15th\",\n    \"16th\",\n    \"17th\",\n    \"18th\",\n    \"19th\",\n    \"20th\",\n    \"21st\",\n    \"22nd\",\n    \"23rd\",\n    \"24th\",\n    \"25th\",\n    \"26th\",\n    \"27th\",\n    \"28th\",\n    \"29th\",\n    \"30th\",\n    \"31st\",\n  ];\n\n  var words = str.toLowerCase().split(\" \");\n\n  var isSpokenWord = false;\n  var isStringDate = false;\n  var monthBeforeDay = null;\n  var keywords = \"\";\n  var month = \"\";\n  var monthCandidates = [];\n  var day = \"\";\n\n  // search for any occurences of commonly spoken words\n  for (let i = 0; i < spokenWords.length; i++) {\n    var word = spokenWords[i];\n    if (words.indexOf(word) !== -1) {\n      keywords = word;\n      isSpokenWord = true;\n      break;\n    }\n  }\n\n  // if we don't find any commonly spoken words, look for string representations of dates\n  if (isSpokenWord === false) {\n    // look for months\n    for (let i = 0; i < words.length; i++) {\n      let word = words[i];\n      if (months.indexOf(word) !== -1) {\n        monthCandidates.push(word);\n      }\n    }\n\n    console.log(words);\n    console.log(monthCandidates);\n\n    // if we found a month, look on either side of it for a date\n    if (monthCandidates.length > 0) {\n      // check each month candidate\n      for (let f = 0; f < monthCandidates.length; f++) {\n        var monthCandidate = monthCandidates[f];\n        const monthIndex = getPosition(words, monthCandidate, f + 1);\n        var dateCandidates = [];\n        if (monthIndex - 1 >= 0)\n          dateCandidates.push({\n            index: monthIndex - 1,\n            date: words[monthIndex - 1],\n          });\n        if (monthIndex + 1 < words.length)\n          dateCandidates.push({\n            index: monthIndex + 1,\n            date: words[monthIndex + 1],\n          });\n\n        // check to see if either of these dateCandidates are actual dates with suffixes\n        for (let i = 0; i < dateCandidates.length; i++) {\n          const dateCandidate = dateCandidates[i].date;\n          const idx = dateCandidates[i].index;\n          if (daysWithSuffix.indexOf(dateCandidate) !== -1) {\n            day = dateCandidate;\n            if (idx > monthIndex) monthBeforeDay = true;\n            else monthBeforeDay = false;\n            break;\n          }\n        }\n\n        // if nothing was found, then we look for numeric representations\n        if (day === \"\") {\n          for (let i = 0; i < dateCandidates.length; i++) {\n            const dateCandidate = parseInt(dateCandidates[i].date);\n            const idx = dateCandidates[i].index;\n            if (dateCandidate > 0 && dateCandidate <= 31) {\n              day = dateCandidate;\n              if (idx > monthIndex) monthBeforeDay = true;\n              else monthBeforeDay = false;\n              break;\n            }\n          }\n        }\n\n        // if we found a date, then we have a date value\n        if (day !== \"\") {\n          isStringDate = true;\n          month = monthCandidates[f];\n          break;\n        }\n      }\n    }\n  }\n\n  // create and return the parsed date\n  if (!isSpokenWord && !isStringDate) return { date: \"\", keywords: \"\" };\n  // no date found\n  else if (isSpokenWord && !isStringDate) {\n    var today = new Date();\n    var currYear = today.getFullYear();\n    var currMonth = today.getMonth() + 1;\n    var currDate = today.getDate();\n    var currDayOfTheWeek = today.getDay() + 1;\n\n    if (keywords === \"tomorrow\" || keywords === \"tmr\") {\n      var daysInMonth = 31;\n      var day = (currDate + 1) % daysInMonth;\n      var m = day === 1 ? currMonth + 1 : currMonth;\n      m = m % 12 !== 0 ? m % 12 : 1;\n      var year = m === 1 ? currYear + 1 : currYear;\n\n      return { date: getFormattedDate(year, m, day), keywords: keywords };\n    } else {\n      var dayOfTheWeek = dayOfTheWeekToNumber(keywords); // always going to assume its the next upcoming day\n      var difference = distanceToNextDay(currDayOfTheWeek, dayOfTheWeek);\n      var daysInMonth = 31;\n      var day = (currDate + difference) % daysInMonth;\n      var m = day === 1 ? currMonth + 1 : currMonth;\n      m = m % 12 !== 0 ? m % 12 : 1;\n      var year = m === 1 ? currYear + 1 : currYear;\n\n      return { date: getFormattedDate(year, m, day), keywords: keywords };\n    }\n  } else if (isStringDate && !isSpokenWord) {\n    var today = new Date(); // we will just assume they mean this year (or next year if either come before the current day)\n    var currYear = today.getFullYear();\n    var currMonth = today.getMonth() + 1;\n    var currDay = today.getDate();\n\n    var monthNum = convertMonthToNumber(month);\n    var dayNum = parseInt(day);\n\n    var year = currYear;\n    if (monthNum < currMonth) year = currYear + 1;\n    else if (monthNum === currMonth) {\n      if (dayNum < currDay) year = currYear + 1;\n    } else year = currYear;\n\n    var keywordsToReturn = monthBeforeDay\n      ? month + \" \" + day\n      : day + \" \" + month;\n\n    return {\n      date: getFormattedDate(year, monthNum, dayNum),\n      keywords: keywordsToReturn,\n    };\n  }\n}\n\nfunction convertMonthToNumber(month) {\n  const months = [\n    \"\",\n    \"january\",\n    \"february\",\n    \"march\",\n    \"april\",\n    \"may\",\n    \"june\",\n    \"july\",\n    \"august\",\n    \"september\",\n    \"october\",\n    \"november\",\n    \"december\",\n  ];\n\n  return months.indexOf(month);\n}\n\nfunction dayOfTheWeekToNumber(dayOfTheWeek) {\n  const daysOfTheWeek = [\n    \"\",\n    \"sunday\",\n    \"monday\",\n    \"tuesday\",\n    \"wednesday\",\n    \"thursday\",\n    \"friday\",\n    \"saturday\",\n  ];\n\n  return daysOfTheWeek.indexOf(dayOfTheWeek);\n}\n\nfunction distanceToNextDay(day1, day2) {\n  var diff = 7 - day1 + day2;\n  if (diff !== 7) diff %= 7;\n  return diff;\n}\n\nfunction getFormattedDate(year, month, day) {\n  if (month < 10) month = \"0\" + month.toString();\n  if (day < 10) day = \"0\" + day.toString();\n\n  return year + \"-\" + month + \"-\" + day;\n}\n\nfunction getPosition(array, entry, occurence) {\n  var seen = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === entry) {\n      seen++;\n      if (seen === occurence) return i;\n    }\n  }\n}\n\nvar date = DateParser(\"test december 423 nice august 15 li\");\nconsole.log(date);\n"]},"metadata":{},"sourceType":"module"}